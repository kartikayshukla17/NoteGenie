//
//  YouTubeService.swift
//  ClaudNotes
//
//  Created by Kartikay Shukla on 14/07/25.
//

import Foundation

class YouTubeService {
    private let apiKey: String
    private let baseURL = "https://www.googleapis.com/youtube/v3"
    
    init() {
        self.apiKey = UserDefaults.standard.string(forKey: AppConstants.Keys.youtubeAPIKey) ?? ""
    }
    
    // MARK: - Video Information
    func getVideoInfo(from url: String) async throws -> YouTubeVideoInfo {
        guard let videoId = extractVideoId(from: url) else {
            throw YouTubeError.invalidURL
        }
        
        let endpoint = "\(baseURL)/videos"
        var components = URLComponents(string: endpoint)!
        components.queryItems = [
            URLQueryItem(name: "part", value: "snippet,contentDetails"),
            URLQueryItem(name: "id", value: videoId),
            URLQueryItem(name: "key", value: apiKey)
        ]
        
        guard let requestURL = components.url else {
            throw YouTubeError.invalidURL
        }
        
        let (data, response) = try await URLSession.shared.data(from: requestURL)
        
        guard let httpResponse = response as? HTTPURLResponse,
              httpResponse.statusCode == 200 else {
            throw YouTubeError.apiError
        }
        
        let videoResponse = try JSONDecoder().decode(YouTubeVideoResponse.self, from: data)
        
        guard let video = videoResponse.items.first else {
            throw YouTubeError.videoNotFound
        }
        
        return YouTubeVideoInfo(
            id: video.id,
            title: video.snippet.title,
            description: video.snippet.description,
            duration: parseDuration(video.contentDetails.duration),
            thumbnailURL: video.snippet.thumbnails.medium.url
        )
    }
    
    // MARK: - Captions/Transcript
    func getCaptions(for videoId: String) async throws -> [CaptionTrack] {
        let endpoint = "\(baseURL)/captions"
        var components = URLComponents(string: endpoint)!
        components.queryItems = [
            URLQueryItem(name: "part", value: "snippet"),
            URLQueryItem(name: "videoId", value: videoId),
            URLQueryItem(name: "key", value: apiKey)
        ]
        
        guard let requestURL = components.url else {
            throw YouTubeError.invalidURL
        }
        
        let (data, response) = try await URLSession.shared.data(from: requestURL)
        
        guard let httpResponse = response as? HTTPURLResponse,
              httpResponse.statusCode == 200 else {
            throw YouTubeError.apiError
        }
        
        let captionsResponse = try JSONDecoder().decode(YouTubeCaptionsResponse.self, from: data)
        
        return captionsResponse.items.map { caption in
            CaptionTrack(
                id: caption.id,
                language: caption.snippet.language,
                name: caption.snippet.name,
                isAutoGenerated: caption.snippet.trackKind == "asr"
            )
        }
    }
    
    // MARK: - Helper Methods
    private func extractVideoId(from url: String) -> String? {
        let patterns = [
            "(?:youtube\\.com/watch\\?v=|youtu\\.be/|youtube\\.com/embed/)([^&\\n?#]+)",
            "youtube\\.com/watch\\?.*v=([^&\\n?#]+)"
        ]
        
        for pattern in patterns {
            if let regex = try? NSRegularExpression(pattern: pattern, options: .caseInsensitive) {
                let range = NSRange(location: 0, length: url.count)
                if let match = regex.firstMatch(in: url, options: [], range: range) {
                    let videoIdRange = match.range(at: 1)
                    if videoIdRange.location != NSNotFound {
                        let startIndex = url.index(url.startIndex, offsetBy: videoIdRange.location)
                        let endIndex = url.index(startIndex, offsetBy: videoIdRange.length)
                        return String(url[startIndex..<endIndex])
                    }
                }
            }
        }
        
        return nil
    }
    
    private func parseDuration(_ duration: String) -> TimeInterval {
        // Parse ISO 8601 duration format (PT4M13S)
        let pattern = "PT(?:(\\d+)H)?(?:(\\d+)M)?(?:(\\d+)S)?"
        guard let regex = try? NSRegularExpression(pattern: pattern) else { return 0 }
        
        let range = NSRange(location: 0, length: duration.count)
        guard let match = regex.firstMatch(in: duration, options: [], range: range) else { return 0 }
        
        var totalSeconds: TimeInterval = 0
        
        // Hours
        if match.range(at: 1).location != NSNotFound {
            let hoursRange = match.range(at: 1)
            let startIndex = duration.index(duration.startIndex, offsetBy: hoursRange.location)
            let endIndex = duration.index(startIndex, offsetBy: hoursRange.length)
            if let hours = Double(String(duration[startIndex..<endIndex])) {
                totalSeconds += hours * 3600
            }
        }
        
        // Minutes
        if match.range(at: 2).location != NSNotFound {
            let minutesRange = match.range(at: 2)
            let startIndex = duration.index(duration.startIndex, offsetBy: minutesRange.location)
            let endIndex = duration.index(startIndex, offsetBy: minutesRange.length)
            if let minutes = Double(String(duration[startIndex..<endIndex])) {
                totalSeconds += minutes * 60
            }
        }
        
        // Seconds
        if match.range(at: 3).location != NSNotFound {
            let secondsRange = match.range(at: 3)
            let startIndex = duration.index(duration.startIndex, offsetBy: secondsRange.location)
            let endIndex = duration.index(startIndex, offsetBy: secondsRange.length)
            if let seconds = Double(String(duration[startIndex..<endIndex])) {
                totalSeconds += seconds
            }
        }
        
        return totalSeconds
    }
}

// MARK: - Models
struct YouTubeVideoInfo {
    let id: String
    let title: String
    let description: String
    let duration: TimeInterval
    let thumbnailURL: String
}

struct CaptionTrack {
    let id: String
    let language: String
    let name: String
    let isAutoGenerated: Bool
}

// MARK: - API Response Models
struct YouTubeVideoResponse: Codable {
    let items: [YouTubeVideo]
}

struct YouTubeVideo: Codable {
    let id: String
    let snippet: VideoSnippet
    let contentDetails: ContentDetails
}

struct VideoSnippet: Codable {
    let title: String
    let description: String
    let thumbnails: Thumbnails
}

struct ContentDetails: Codable {
    let duration: String
}

struct Thumbnails: Codable {
    let medium: Thumbnail
}

struct Thumbnail: Codable {
    let url: String
}

struct YouTubeCaptionsResponse: Codable {
    let items: [Caption]
}

struct Caption: Codable {
    let id: String
    let snippet: CaptionSnippet
}

struct CaptionSnippet: Codable {
    let language: String
    let name: String
    let trackKind: String
}

// MARK: - Errors
enum YouTubeError: Error, LocalizedError {
    case invalidURL
    case apiError
    case videoNotFound
    case noAPIKey
    
    var errorDescription: String? {
        switch self {
        case .invalidURL:
            return "Invalid YouTube URL"
        case .apiError:
            return "YouTube API error"
        case .videoNotFound:
            return "Video not found"
        case .noAPIKey:
            return "YouTube API key not configured"
        }
    }
}
